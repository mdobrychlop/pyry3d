#!/usr/bin/env python
from __future__ import division
# -*- coding: utf-8 -*-
#
# 
# www.genesilico.pl 
#

#creates ranked 3D models of macromoleular complexes 
#based on experimental restraints and a whole complex shape.


__author__ = "Joanna M. Kasprzak"
__copyright__ = "Copyright 2010, The PyRy3D Project"
__credits__ = ["Janusz Bujnicki"]
__license__ = "GPL"
__version__ = "0.1.0"
__maintainer__ = "Joanna Kasprzak"
__email__ = "jkasp@amu.edu.pl"
__status__ = "Prototype"

#pyry
from Modules.Error.Errors import RestraintCheckerError
from Modules.Input.vector import count_dist
#math
from math                 import fabs, sqrt

"""
@TODO
modul powinien zawierac dodatkowo:
1. funkcje do pobierania danych kompleksu z pliku pdb
2. funkcje do pobierania danych kompleksu z obiektu bio.pdb
3. funkcje zwracajaca score
4. funkcje zwracajaca atomy w kolizji

dopisac testy do tego modulu
"""

class PairRestraintChecker(object):
    """
        represents violation of distance restraints in one
        PyRyComplex generated by simulator
    """
    
    def __init__(self, structures): #structA, structB):
        self.differs = []               #list of objects containing dist_scores
        self.names = []                 #list of restraint names
        self.structA = structures[0] #structA
        self.structB = structures[1] #structB
        try:
            self.structC = structures[2]
        except: pass
        try:
            self.structD = structures[3]
        except: pass
        
    def __str__(self):
        return "%s" % (self.final_dist_score)
        
    def calculate_differences(self, rest, Astruct, Bstruct, restype = "dist"):
        """
        for a given restraint checks all distances between defined atoms, finds
        the smalest one and calls method which recalculate this restraint score
        if other restraint for the same components and atoms was defined
        """
       #     print "checking", rest.first.res1_num, rest.second.res1_num, rest.first.res2_num, rest.second.res2_num
        diffs = []
        #calculate Multiple Restraint 1Angstrom < 1-10 "C" < 6Angstrom
        for i in xrange(rest.first.res1_num, rest.first.res2_num+1):
            for j in xrange(rest.second.res1_num, rest.second.res2_num+1):
                at1 = self.get_rest_atom(i, rest.first.atom_name,  Astruct, rest.chains[0])
                at2 = self.get_rest_atom(j, rest.second.atom_name, Bstruct, rest.chains[1])
                
                #calculate difference between real and assumed "ideal" restraint distance
                act_dif = self.__check_distance(rest, at1, at2, rest.type) #restype)
                
                #if one condition is fulfilled, than score for this particular multiple restraint is 0 :-)
                if round(act_dif, 5) == 0.0 :
                    break
                #collect all differences for given restraint
                diffs.append(act_dif)
                
        #minimal difference within range restraint
        if len(diffs) != 0 :  min_dif = self.find_min_dif(diffs)
        else: min_dif = 0.
            
        
        #print "MFi", min_dif, restype

        #calculate difference score
        #if restype == "dist":
        if rest.type == "dist":
            return self.calculate_dif_score(min_dif, rest)
        elif rest.type == "relation":
            if len(diffs) != 0 :  max_dif = self.find_max_dif(diffs)
            else: max_dif = 0.
            
            #return self.calculate_dif_score(min_dif, rest)
            return min_dif, max_dif
        else:
            return min_dif
        
    def calculate_differences_rel2(self, rest, Astruct, Bstruct, restype = "dist"):
        """
        for a given restraint checks all distances between defined atoms, finds
        the smalest one and calls method which recalculate this restraint score
        if other restraint for the same components and atoms was defined
        """
        #print "checking", rest.first.res1_num, rest.second.res1_num, rest.restraint.dist
        diffs = []
        #calculate Multiple Restraint 1Angstrom < 1-10 "C" < 6Angstrom
        for i in xrange(rest.third.res1_num, rest.third.res2_num+1):
            for j in xrange(rest.fourth.res1_num, rest.fourth.res2_num+1):
                at1 = self.get_rest_atom(i, rest.third.atom_name,  Astruct, rest.chains[2])
                at2 = self.get_rest_atom(j, rest.fourth.atom_name, Bstruct, rest.chains[3])
                
                #calculate difference between real and assumed "ideal" restraint distance
                act_dif = self.__check_distance(rest, at1, at2, rest.type) #restype)

                #print "!", i, j, act_dif
                
                #if one condition is fulfilled, than score for this particular multiple restraint is 0 :-)
                if round(act_dif, 5) == 0.0 :
                    break
                #collect all differences for given restraint
                diffs.append(act_dif)
                
        #minimal difference within range restraint
        if len(diffs) != 0 :  min_dif = self.find_min_dif(diffs)
        else: min_dif = 0.
            
        #calculate difference score

        if rest.type == "dist":
            return self.calculate_dif_score(min_dif, rest)
        elif rest.type == "relation":
            if len(diffs) != 0 :  max_dif = self.find_max_dif(diffs)
            else: max_dif = 0.
            
            #return self.calculate_dif_score(min_dif, rest)
            return min_dif, max_dif
        else:
            return min_dif
    
    #def check(self, interactions):
    #    rest_score, pair_diffscores = self.check_restraints_in_complex(interactions)
    #    return pair_diffscores
        
    def calculate(self, restraint):
        if restraint.type == "dist":
            return self.check_distance_restraint(restraint)
        elif restraint.type == "relation":
            return self.check_relation_restraint(restraint)
            
    #def check_restraints_in_complex(self, interactions):
    #    """
    #    checks if a restraints provided by the user are not violated in simulated components
    #    Parameters:
    #    -----------
    #        interactions    : list of all distance restraints
    #    """
    #    
    #    pair_restraints = self.__get_corresponding_restraints(self.structA, self.structB, interactions.sd_interactions)
    #    if pair_restraints:
    #        for rest in pair_restraints:
    #            if rest.type == "dist":
    #                print "llllllllllllllllllllllllllllll"
    #                self.check_distance_restraint()
    #            elif rest.type == "relation":
    #                print "########################"
    #                self.check_relation_restraint()
    #            #Astruct = self.get_component_structure(rest.chains[0], [self.structA, self.structB])
    #            #Bstruct = self.get_component_structure(rest.chains[1], [self.structA, self.structB])
    #            
    #            #self.calculate_differences(rest, Astruct, Bstruct)
    #        
    #        #sum all dif scores for all restraints for st1st2 pair
    #        total_score = 0.0
    #        
    #        for d in self.differs:
    #            total_score += (fabs(d.dif))**2
    #            #print "score elem", d.dif, total_score
    #        #print "total score!", sqrt(total_score), total_score, self.differs
    #        return total_score, self.differs 
    #    else:
    #        return 0, []
        
    def check_distance_restraint(self, rest):
        Astruct = self.get_component_structure(rest.chains[0], [self.structA, self.structB])
        Bstruct = self.get_component_structure(rest.chains[1], [self.structA, self.structB])     
        return self.calculate_differences(rest, Astruct, Bstruct)
        
    def check_relation_restraint(self, rest):
        Astruct = self.get_component_structure(rest.chains[0], [self.structA, self.structB])
        Bstruct = self.get_component_structure(rest.chains[1], [self.structA, self.structB])
        Cstruct = self.get_component_structure(rest.chains[2], [self.structC, self.structD])
        Dstruct = self.get_component_structure(rest.chains[3], [self.structC, self.structD]) 
        min_dif1, max_dif1 = self.calculate_differences(rest, Astruct, Bstruct)
        min_dif2, max_dif2 = self.calculate_differences_rel2(rest, Cstruct, Dstruct)
        if rest.restraint.relation == "<=" or rest.restraint.relation == "<":
            if min_dif1 <= max_dif2:
                penalty = 0.0 
            else: penalty = 100.0
        if rest.restraint.relation == ">=" or rest.restraint.relation == ">":
            if max_dif1 >= min_dif2:
                penalty = 0.0 
            else: penalty = 100
        return penalty
    
        
    def check_symmetry_restraints_in_complex(self, interactions):
        """
        checks if a restraints provided by the user are not violated in simulated components
        Parameters:
        -----------
            interactions    : list of all distance restraints
        """
        sym_distances = []
        pair_restraints = self.__get_corresponding_restraints(self.structA, self.structB, interactions.symmetry_interactions)
        if pair_restraints:
            for rest in pair_restraints:
                Astruct = self.get_component_structure(rest.chains[0], [self.structA, self.structB])
                Bstruct = self.get_component_structure(rest.chains[1], [self.structA, self.structB])
                
                dist = self.calculate_differences(rest, Astruct, Bstruct, "symmetry")
                sym_distances.append(dist)
        return sym_distances
        
    def find_min_dif(self, difscores):
        """
           for a list of distance differences it returns smallest difference
           e.g. [-1,10,2] will return -1
        """
        dif_min = difscores[0]
        for dif in difscores[1:]:
            if round(dif, 5) == 0.     : return 0.
            if abs(dif_min) > abs(dif) : dif_min = dif
        return dif_min
    
    def find_max_dif(self, difscores):
        """
           for a list of distance differences it returns smallest difference
           e.g. [-1,10,2] will return 10
        """
        dif_max = difscores[0]
        for dif in difscores[1:]:
            if round(dif, 5) == 0.     : return 0.
            if abs(dif_max) < abs(dif) : dif_max = dif
        return dif_max


    def __get_corresponding_restraints(self, st1, st2, interactions):
        """
            retrieves all user defined restraints for given pair of structures 
        """
        pair_restraints = []
        
        
        #for restraint in interactions.sd_interactions:
        for restraint in interactions:
            if restraint.chains == [st1.chain, st2.chain] or \
               restraint.chains == [st2.chain, st1.chain]:
                pair_restraints.append(restraint)
        return pair_restraints
    
    def get_differ_obj(self, name):
        for di in self.differs:
            if di.name == name: return di
        
    def calculate_dif_score(self, dif, restr, type = "sd"):
        """
        score for restraints is formulated as difference between required distance
        (by the user) and real distance appearing in simulated complex
            
        for range restraints like:
            5 < dist <= 10
        score is 0 when the condition is true
        when dist > 10, score = dist - 10 (positive value)
        when dist < 5, score = dist - 5 (negative value)
            
        all results are stored in a dictionary {"res_name" : sum_dist_score_objt}
        
        type:
        sd - regular distance restraints between atoms
        sa -surface accessibility as distance between atoms and mappoints
        pd - point distance as distance between atoms and points in 3D space
        """
        #name example A12B34
        if type == "sd":
            name = restr.first.chain_id+str(restr.first.res1_num)+restr.second.chain_id+str(restr.second.res1_num)
        else:
            name = restr.first.chain_id+str(restr.first.res1_num)+type

        if name in self.names:

            #range restraint eg. 5 < dist < 10
            differ = self.get_differ_obj(name)
            differ.counter += 1
            if differ.counter > 2:
                raise RestraintCheckerError("You provided more than 2 different\
                                    restraints for the same residues %s"%(name))
            differ.which_case(dif, restr.restraint.weight)
        #regular single restraint
        else:
            differ = Differ(name)
            differ.set_difscore(dif, restr.restraint.weight)
            differ.id = restr.id
            differ.set_chains(restr)
            self.differs.append(differ)
            self.names.append(name)
        return differ.dif
            
    def __check_distance(self, restr, atom1, atom2, restype="dist"):
        """
        calculates distance between given pair of atoms and compares its value
        to one assigned by the user in restraints file; method returns punish
        value depending on
        Parameters:
        -----------
            restr       :   single restraint object
            atom1       :   Bio.PDB.Atom object for first restrint atom
            atom2       :   Bio.PDB.Atom object for second restrint atom
        Returns:
        --------
            dif         :   difference between restraint distance and real
                            distance that appears in complex
        """
        real_dist = atom1 - atom2 #distance between atoms in simulated complex
        #print "********8", real_dist
        #if restype == "dist":
        if restr.type == "dist":
            dif = real_dist - restr.restraint.dist

            try:    
                if restr.restraint.relation == "<=" or restr.restraint.relation == "<":
                    if real_dist <= restr.restraint.dist:
                        
                        dif = 0.0 #01*dif
                        #print "!!!", atom1.get_parent().id, atom2.get_parent().id, dif, real_dist, restr.restraint.dist, restr.restraint.relation
                if restr.restraint.relation == ">=" or restr.restraint.relation == ">":
                    if real_dist >= restr.restraint.dist:
                        dif = 0.0 #01*dif
            except: pass
        #if restr.type == "relation":
        #    #print "999999999999", dir(restr.third), restr.third.atom_name
        #    dif = real_dist
        #    
        else:
            dif = real_dist
        #print "!!!::::", atom1.get_parent().id, atom2.get_parent().id, dif, real_dist, restr.restraint.dist, restr.restraint.relation    
        return dif

    def get_component_structure(self, chain, components_pair):
        """
            retrieves structure coordinates for given chainname
        """            
        for component in components_pair:
            if component.chain == chain:
                return component.struct
            
    def get_rest_atom(self, res_number, atom_name, structure, chain):
        """
            gets residues BioPDB Atom instance indicated in a given restaint
        Parameters:
        -----------
            res_number    : numer of residue mentioned in restraint definition
                            e.g. A34; A is res_name, 34 is res_number
            atom_name     : e.g. CA C4'
            structure     : Bio.PDB structure of given chain
        Returns:
        --------
            mentioned atom as Bio.PDB.Atom instance
        """
        return structure[0][chain][res_number][atom_name]
        

class SymmetricRestraintChecker(PairRestraintChecker):

    def calculate(self, restraint):
        Astruct = self.get_component_structure(restraint.chains[0], [self.structA, self.structB])
        Bstruct = self.get_component_structure(restraint.chains[1], [self.structA, self.structB])
        return self.calculate_differences(restraint, Astruct, Bstruct, "symmetry")
        
    def check(self, interactions):
        return self.check_symmetry_restraints_in_complex(interactions)


class SingleComponentRestraintChecker(PairRestraintChecker):
    """
    class storing methods to operate on single component restraints like
    Surface Accessibility od Point Distance
    """
    def __init__(self, component, type = 'whatever'):
        self.differs = []               #list of objects containing dist_scores
        self.names = []                 #list of restraint names
        self.component = component
        self.type = type
        
    def calculate(self, restraint):
        struct = self.component.pyrystruct.struct
        return self.__calculate_single_component_differences(restraint, struct, self.type)
   
    def check(self, restraints):
        return self.check_single_component_restraints_in_complex(restraints)
    
    def __calculate_single_component_differences(self, rest, struct, type):
        """
        for a given restraint checks all distances between defined atoms, finds
        the smalest one and calls method which recalculate this restraint score
        if other restraint for the same components and atoms was defined
        """
        diffs = []

        #calculate Multiple Restraint 1Angstrom < 1-10 "C" < 6Angstrom
        for i in xrange(rest.first.res1_num, rest.first.res2_num+1):
            for j in xrange(0, len(rest.points)):
                ob1 = self.get_rest_atom(i, rest.first.atom_name,  struct, rest.chains[0])
                ob2 = rest.points[j]
                #calculate difference between real and assumed "ideal" restraint distance
                act_dif = self.__check_3dpoint_distance(rest, ob1, ob2)
                #if one condition is fulfilled, than score for this particular multiple restraint is 0 :-)
                if round(act_dif, 5) == 0.0 :
                    break
                #collect all differences for given restraint
                diffs.append(act_dif)
                
        #minimal difference within range restraint
        if len(diffs) != 0 :  min_dif = self.find_min_dif(diffs)
        else: min_dif = 0.

        #calculate difference score
        return self.calculate_dif_score(min_dif, rest, type)
        
    def check_single_component_restraints_in_complex(self, single_interactions):
        """
        
        points - surfacepoints for sa_interactions
        single_interactions - sa_interactions or pd_interactions working on one component only!!
        """
        comp_restraints = self.__get_all_restraints_for_chain(self.component, single_interactions)
        if comp_restraints:
            for rest in comp_restraints:
                struct = self.component.pyrystruct.struct
     
                self.__calculate_single_component_differences(rest, struct, self.type)
            return (self.differs[0].dif)**2
        else:
            #print "no restraint for given pair RS 0!!"
            return 0
        
    def __get_all_restraints_for_chain(self, component, single_interactions):
        """
        retrieves all user defined restraints for a given chain
        
        works for both sa_interactions and pd_interactions
        """
        component_restraints = []
        
        for restraint in single_interactions:
            if restraint.chains[0] == component.pyrystruct.chain:
                component_restraints.append(restraint)
        return component_restraints
    
    def __check_3dpoint_distance(self, restr, atom, point):
        """
        calculates distance between given pair of atoms and compares its value
        to one assigned by the user in restraints file; method returns punish
        value depending on
        Parameters:
        -----------
            restr       :   single restraint object
            atom1       :   Bio.PDB.Atom object for first restrint atom
            point       :   point in 3D space
        Returns:
        --------
            dif         :   difference between restraint distance and real
                            distance that appears in complex
        """
        #real_dist = atom1.coord - point.coord #distance between atoms in simulated complex
        real_dist = count_dist(atom.coord, point.coord)
        #print "Scoring restraints diff", restr.type, real_dist, restr.restraint.dist #, -(restr.weight*abs(dif))
        return real_dist - restr.restraint.dist #restraint_dist


        
class Differ(object):
    """
        helping class - a container to store information about restraints
    """
    
    def __init__(self, name):
        self.dif      = 0.0               #actual distance score
        self.name     = name             #restraint name
        self.counter  = 1             #how many times this restraint occur
        self.chains   = []             #list of chains involved in the interaction
        self.id       = None           #restraint object id
    
    def __str__(self):
        return "%s %s"%(self.name, self.dif)
        
    def __calc_between_dist(self):
        """
        when real dist is in range of both restr_dist
        e.g. 1< 4 < 5; (1,5 are range restr, 4 is real dist in analysed complex)
        """
        self.dif = 0.00
        print "between", 0
        
    def __calc_larger_dist(self, dif, score_weight):
        """
        simulated dist is larger than both values
        (for first and second condition for the same residues) - choose smaller
        eg. real dist is 12 for range restraints 5 < dist < 10
        """
        self.dif = min(self.dif, dif) * score_weight
        
    def set_difscore(self, difscore, score_weight):
        
        self.dif = difscore * score_weight
        
    def __calc_smaller_dist(self, dif, score_weight):
        """
        simulated dist is smaller than both values - choose larger
        eg. real dist is 2 for range restraints 5 < dist < 10
        """
        self.dif = max(self.dif, dif) * score_weight
        
    def which_case(self, dif, score_weight):
        """
           decides what is the relation between actual distance and range values
        """
        print "which case", score_weight
        if self.dif > 0 and dif > 0: self.__calc_larger_dist(dif, score_weight)
        elif self.dif < 0 and dif < 0: self.__calc_smaller_dist(dif, score_weight)
        elif (self.dif * dif) < 0 : self.__calc_between_dist()
        elif dif == 0: pass
        
    def set_chains(self, restraint):
        ch1 = restraint.first.chain_id
        if hasattr(restraint, "second"):
            ch2 = restraint.second.chain_id 
            self.chains = [ch1, ch2]
        else: self.chains = [ch1]
    
